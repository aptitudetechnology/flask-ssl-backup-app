# paths.py

import os
from pathlib import Path
from typing import Optional, Dict
from datetime import datetime, timedelta # Added for cleanup_old_backups

class AppPaths:
    """Centralized path management using pathlib"""

    def __init__(self, app_root: Optional[Path] = None):
        # Determine the application root. Prioritize explicit app_root, then a common parent structure.
        # If app_root is not provided, assume the project root is the parent of the directory containing paths.py
        self.app_root = Path(app_root) if app_root else Path(__file__).parent.parent
        self._ensure_directories()

    # Core application paths
    @property
    def data_dir(self) -> Path: # Add a data directory to contain DB, GPG, etc.
        return self.app_root / "data"

    @property
    def database_file(self) -> Path:
        return self.data_dir / "customers.db" # Database now resides in data/

    @property
    def static_dir(self) -> Path:
        return self.app_root / "static"

    @property
    def templates_dir(self) -> Path:
        return self.app_root / "templates"

    # SSL certificate paths
    @property
    def ssl_dir(self) -> Path:
        # Use data_dir for sensitive SSL files if they are generated by the app
        # or stick to app_root/ssl if they are manually placed there.
        # For simplicity, keeping it at app_root/ssl as per original, but data_dir/ssl could be an option.
        return Path(os.environ.get('SSL_CERT_DIR', self.app_root / "ssl"))

    @property
    def ssl_cert_file(self) -> Path:
        return Path(os.environ.get('SSL_CERT_PATH', self.ssl_dir / "cert.pem"))

    @property
    def ssl_key_file(self) -> Path:
        return Path(os.environ.get('SSL_KEY_PATH', self.ssl_dir / "key.pem"))

    # Backup paths
    @property
    def backup_dir(self) -> Path:
        # Backups usually go into a specific backup folder, often within data/
        return Path(os.environ.get('BACKUP_DIR', self.data_dir / "backups"))

    @property
    def temp_backup_dir(self) -> Path: # This seems to be the one you intend for temporary backup files
        return self.backup_dir / "temp"

    @property
    def archive_backup_dir(self) -> Path:
        return self.backup_dir / "archive"

    # GPG paths
    @property
    def gpg_home_dir(self) -> Path:
        # ✅ CRITICAL CHANGE: GPG home directory is now isolated within app's data folder
        return Path(os.environ.get('GPG_HOME_DIR', self.data_dir / "gpg"))

    @property
    def gpg_keys_dir(self) -> Path:
        # This directory might not be used by gnupg directly; gnupg manages its own structure
        # within gpg_home_dir. Keeping it for now but it might not be strictly necessary depending
        # on how you plan to manage keys outside of gnupg's standard.
        return self.gpg_home_dir / "keys"

    # Logging paths
    @property
    def log_dir(self) -> Path:
        return Path(os.environ.get('LOG_DIR', self.app_root / "logs"))

    @property
    def log_file(self) -> Path:
        return self.log_dir / "app.log"

    @property
    def error_log_file(self) -> Path:
        return self.log_dir / "error.log"

    @property
    def backup_log_file(self) -> Path:
        return self.log_dir / "backup.log"

    @property
    def gpg_log_file(self) -> Path: # ✅ ADDED: GPG specific log file
        return self.log_dir / "gpg_backup.log"

    # Utility methods
    def _ensure_directories(self):
        # Ensure data_dir is created first, as other paths depend on it
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.gpg_home_dir.mkdir(parents=True, exist_ok=True) # Ensure GPG home dir is created

        dirs = [
            self.backup_dir,
            self.temp_backup_dir,
            self.archive_backup_dir,
            self.log_dir,
            self.ssl_dir,
            self.static_dir,
            self.templates_dir
            # self.gpg_keys_dir # Gnupg usually creates this itself if needed, but no harm in ensuring
        ]
        for directory in dirs:
            try:
                directory.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                print(f"Warning: Cannot create directory {directory} - permission denied")
            except Exception as e:
                print(f"Warning: Failed to create directory {directory}: {str(e)}")

    def validate_paths(self) -> Dict[str, bool]:
        dirs = {
            'app_root_exists': self.app_root.is_dir(),
            'data_dir_exists': self.data_dir.is_dir(),
            'backup_dir_exists': self.backup_dir.is_dir(),
            'log_dir_exists': self.log_dir.is_dir(),
            'ssl_dir_exists': self.ssl_dir.is_dir(),
            'static_dir_exists': self.static_dir.is_dir(),
            'templates_dir_exists': self.templates_dir.is_dir(),
            'gpg_home_dir_exists': self.gpg_home_dir.is_dir() # ✅ ADDED validation for GPG home
        }
        results = {k: v for k, v in dirs.items()} # Use results from is_dir directly
        
        files = {
            'ssl_cert_file': self.ssl_cert_file,
            'ssl_key_file': self.ssl_key_file,
            'database_file': self.database_file,
            'log_file': self.log_file,
            'error_log_file': self.error_log_file,
            'backup_log_file': self.backup_log_file,
            'gpg_log_file': self.gpg_log_file # ✅ ADDED validation for GPG log
        }
        results.update({f"{k}_exists": v.exists() for k, v in files.items()})
        return results

    def get_backup_filename(self, backup_type="regular", timestamp=None) -> str:
        # Assumes datetime import is handled globally or passed in
        if not timestamp:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"backup_{backup_type}_{timestamp}.db"

    def get_gpg_backup_filename(self, original_filename: str) -> str:
        return f"{original_filename}.gpg"

    def cleanup_old_backups(self, max_age_days=30) -> int:
        # Assumes datetime and timedelta imports are handled globally or passed in
        cutoff = datetime.now() - timedelta(days=max_age_days)
        count = 0
        if not self.backup_dir.exists():
            return 0
        try:
            for f in self.backup_dir.glob("backup_*.db*"):
                if f.is_file() and datetime.fromtimestamp(f.stat().st_mtime) < cutoff:
                    f.unlink()
                    count += 1
        except Exception as e:
            print(f"Error during backup cleanup: {e}")
        return count